<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>風の可視化</title>
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <style>
        .info-box {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: sans-serif;
            z-index: 999;
            display: none;
        }
        #filter-ui {
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: sans-serif;
            z-index: 999;
        }

        #p-value-box {
            position: fixed;
            top: 80px; /* filter-ui のすぐ下に配置 */
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: sans-serif;
            z-index: 999;
            width: 200px; 
            height: 130px;
            font-size: 10px;
        }
    </style>
    <script>
        // 地方と都道府県のマッピング
        const regionalMapping = {
            '北海道': ['北海道'],
            '東北': ['青森県', '岩手県', '宮城県', '秋田県', '山形県', '福島県'],
            '関東': ['茨城県', '栃木県', '群馬県', '埼玉県', '千葉県', '東京都', '神奈川県'],
            '中部': ['新潟県', '富山県', '石川県', '福井県', '山梨県', '長野県', '岐阜県', '静岡県', '愛知県'],
            '近畿': ['三重県', '滋賀県', '京都府', '大阪府', '兵庫県', '奈良県', '和歌山県'],
            '中国': ['鳥取県', '島根県', '岡山県', '広島県', '山口県'],
            '四国': ['徳島県', '香川県', '愛媛県', '高知県'],
            '九州': ['福岡県', '佐賀県', '長崎県', '熊本県', '大分県', '宮崎県', '鹿児島県', '沖縄県']
        };

        // 地方ごとの色
        const regionalColors = {
            '北海道': '#ADD8E6', // LightBlue
            '東北': '#87CEEB',  // SkyBlue
            '関東': '#6495ED',  // CornflowerBlue
            '中部': '#4682B4',  // SteelBlue
            '近畿': '#CD5C5C',  // IndianRed
            '中国': '#DC143C',  // Crimson
            '四国': '#F08080',  // LightCoral
            '九州': '#FF0000'   // Red
        };
        
        // 都道府県名から地方の色を返すヘルパー関数
        function getRegionalColor(prefecture) {
            for (const region in regionalMapping) {
                if (regionalMapping.hasOwnProperty(region) && regionalMapping[region].includes(prefecture)) {
                    return regionalColors[region];
                }
            }
            return '#808080'; // デフォルト色
        }

        AFRAME.registerComponent('csv-graph', {
            schema: {
                filterEnabled: { type: 'boolean', default: false },
                showTrail: { type: 'boolean', default: false }
            },
            init: function () {
                const el = this.el;
                const infoBox = document.createElement('div');
                infoBox.className = 'info-box';
                document.body.appendChild(infoBox);

                const scene = document.querySelector('a-scene');
                const filterUi = document.getElementById('filter-ui');
                const regionalFilter = document.getElementById('regional-filter');
                const pValueBox = document.getElementById('p-value-box');

                let rawDataPoints = [];
                let maxAvgWindSpeed = -Infinity;
                let minAvgWindSpeed = Infinity;
                let maxHighWindDays10 = -Infinity;
                let minHighWindDays10 = Infinity;
                let maxHighWindDays15 = -Infinity;
                let minHighWindDays15 = Infinity;
                let monthLabels = [];
                let axisLabels = {};
                let axisUnits = {};
                
                let currentMonthIndex = 0;
                let animationInterval = null;
                let animationMode = false;
                let currentRegionFilter = '';

                let permanentInfo = null; // クリックで表示する情報を保持する変数

                // データを読み込み、前処理
                const processData = (data) => {
                    const rows = data.split('\n');
                    
                    const header = rows.length > 1 ? rows[1].split(',') : [];
                    axisLabels = {
                        avgWindSpeed: header[19] ? header[19].trim().split('(')[0].trim() : '平均風速',
                        highWindDays10: header[20] ? header[20].trim().split('(')[0].trim() : '10m/s以上の日数',
                        highWindDays15: header[21] ? header[21].trim().split('(')[0].trim() : '15m/s以上の日数',
                    };
                    axisUnits = {
                        avgWindSpeed: header[19] ? (header[19].trim().match(/\(([^)]+)\)/) ? header[19].trim().match(/\(([^)]+)\)/)[1] : '') : '',
                        highWindDays10: header[20] ? (header[20].trim().match(/\(([^)]+)\)/) ? header[20].trim().match(/\(([^)]+)\)/)[1] : '') : '',
                        highWindDays15: header[21] ? (header[21].trim().match(/\(([^)]+)\)/) ? header[21].trim().match(/\(([^)]+)\)/)[1] : '') : '',
                    };

                    rows.slice(2).forEach(row => {
                        const columns = row.split(',');
                        const month = columns[3] ? columns[3].trim() : '';
                        const prefecture = columns[1] ? columns[1].trim() : '';

                        if (columns.length > 40 && month !== '年' && month !== '') {
                            const avgWindSpeed = parseFloat(columns[19]);
                            const highWindDays10 = parseFloat(columns[20]);
                            const highWindDays15 = parseFloat(columns[21]);

                            if (!isNaN(avgWindSpeed) && !isNaN(highWindDays10) && !isNaN(highWindDays15)) {
                                maxAvgWindSpeed = Math.max(maxAvgWindSpeed, avgWindSpeed);
                                minAvgWindSpeed = Math.min(minAvgWindSpeed, avgWindSpeed);
                                maxHighWindDays10 = Math.max(maxHighWindDays10, highWindDays10);
                                minHighWindDays10 = Math.min(minHighWindDays10, highWindDays10);
                                maxHighWindDays15 = Math.max(maxHighWindDays15, highWindDays15);
                                minHighWindDays15 = Math.min(minHighWindDays15, highWindDays15);

                                if (!monthLabels.includes(month)) {
                                    monthLabels.push(month);
                                }
                                
                                rawDataPoints.push({
                                    prefecture: prefecture,
                                    month: month,
                                    avgWindSpeed: avgWindSpeed,
                                    highWindDays10: highWindDays10,
                                    highWindDays15: highWindDays15
                                });
                            }
                        }
                    });

                    monthLabels.sort((a, b) => {
                        const aNum = parseInt(a.replace('月', ''), 10);
                        const bNum = parseInt(b.replace('月', ''), 10);
                        return aNum - bNum;
                    });

                    // フィルターUIに地方のオプションを追加
                    if (this.data.filterEnabled) {
                        for (const region in regionalMapping) {
                            const option = document.createElement('option');
                            option.value = region;
                            option.textContent = region;
                            regionalFilter.appendChild(option);
                        }
                        regionalFilter.addEventListener('change', (e) => {
                            currentRegionFilter = e.target.value;
                            stopAnimation();
                            drawGraph();
                            permanentInfo = null; // フィルター変更で情報をリセット
                        });
                        filterUi.style.display = 'block';
                    }

                    drawTicks(maxHighWindDays10, minHighWindDays10, maxAvgWindSpeed, minAvgWindSpeed, maxHighWindDays15, minHighWindDays15);
                    
                    drawGraph();
                    updateAxisLabels(0);
                };

                const drawTicks = (maxX, minX, maxY, minY, maxZ, minZ) => {
                    const scaleFactor = 10;
                    const el = document.querySelector('a-scene');

                    const tickCountX = 5;
                    const tickStepX = (maxX - minX) / tickCountX;
                    for (let i = 0; i <= tickCountX; i++) {
                        const tickValue = minX + i * tickStepX;
                        const x = (tickValue - minX) * scaleFactor;
                        const tickLine = document.createElement('a-entity');
                        tickLine.setAttribute('line', `start: ${x} 0 0; end: ${x} 0 1; color: #ff0000; opacity: 0.5`);
                        el.appendChild(tickLine);

                        const tickText = document.createElement('a-text');
                        tickText.setAttribute('value', `${tickValue.toFixed(1)}`);
                        tickText.setAttribute('position', `${x} -1 0`);
                        tickText.setAttribute('color', 'black');
                        tickText.setAttribute('width', '5');
                        tickText.classList.add('graph-label');
                        el.appendChild(tickText);
                    }

                    const tickCountY = 5;
                    const tickStepY = (maxY - minY) / tickCountY;
                    for (let i = 0; i <= tickCountY; i++) {
                        const tickValue = minY + i * tickStepY;
                        const y = (tickValue - minY) * scaleFactor;

                        const tickLine = document.createElement('a-entity');
                        tickLine.setAttribute('line', `start: 0 ${y} 0; end: 1 ${y} 0; color: #00ff00; opacity: 0.5`);
                        el.appendChild(tickLine);
                        
                        const tickText = document.createElement('a-text');
                        tickText.setAttribute('value', `${tickValue.toFixed(1)}`);
                        tickText.setAttribute('position', `-1 ${y} 0`);
                        tickText.setAttribute('color', 'black');
                        tickText.setAttribute('width', '5');
                        tickText.classList.add('graph-label');
                        el.appendChild(tickText);
                    }

                    const tickCountZ = 5;
                    const tickStepZ = (maxZ - minZ) / tickCountZ;
                    for (let i = 0; i <= tickCountZ; i++) {
                        const tickValue = minZ + i * tickStepZ;
                        const z = (tickValue - minZ) * scaleFactor;

                        const tickLine = document.createElement('a-entity');
                        tickLine.setAttribute('line', `start: 0 0 ${z}; end: 0 1 ${z}; color: #0000ff; opacity: 0.5`);
                        el.appendChild(tickLine);
                        
                        const tickText = document.createElement('a-text');
                        tickText.setAttribute('value', `${tickValue.toFixed(1)}`);
                        tickText.setAttribute('position', `0 -1 ${z}`);
                        tickText.setAttribute('color', 'black');
                        tickText.setAttribute('width', '5');
                        tickText.classList.add('graph-label');
                        el.appendChild(tickText);
                    }
                };
                
                const drawGraph = () => {
                    const month = monthLabels[currentMonthIndex];
                    let filteredData = rawDataPoints.filter(p => p.month === month);

                    if (currentRegionFilter) {
                        const prefecturesInRegion = regionalMapping[currentRegionFilter];
                        filteredData = filteredData.filter(p => prefecturesInRegion.includes(p.prefecture));
                    }

                    while (el.firstChild) {
                        el.removeChild(el.firstChild);
                    }
                    
                    const scaleFactor = 10;
                    const xOffset = 0;
                    const yOffset = 0;
                    const zOffset = 0;

                    if (this.data.showTrail && currentRegionFilter) {
                        const prefecturesInRegion = regionalMapping[currentRegionFilter];
                        prefecturesInRegion.forEach(prefecture => {
                            const trailData = rawDataPoints.filter(p => p.prefecture === prefecture);
                            if (trailData.length > 1) {
                                for (let i = 0; i < trailData.length - 1; i++) {
                                    const p1 = trailData[i];
                                    const p2 = trailData[i + 1];
                                    
                                    const x1 = (p1.highWindDays10 - minHighWindDays10) * scaleFactor + xOffset;
                                    const y1 = (p1.avgWindSpeed - minAvgWindSpeed) * scaleFactor + yOffset;
                                    const z1 = (p1.highWindDays15 - minHighWindDays15) * scaleFactor + zOffset;
                                    
                                    const x2 = (p2.highWindDays10 - minHighWindDays10) * scaleFactor + xOffset;
                                    const y2 = (p2.avgWindSpeed - minAvgWindSpeed) * scaleFactor + yOffset;
                                    const z2 = (p2.highWindDays15 - minHighWindDays15) * scaleFactor + zOffset;

                                    const trailLine = document.createElement('a-entity');
                                    trailLine.setAttribute('line', `start: ${x1} ${y1} ${z1}; end: ${x2} ${y2} ${z2}; color: ${getRegionalColor(p1.prefecture)}; opacity: 0.7`);
                                    el.appendChild(trailLine);
                                }
                            }
                        });
                    }

                    filteredData.forEach(point => {
                        const x = (point.highWindDays10 - minHighWindDays10) * scaleFactor + xOffset;
                        const y = (point.avgWindSpeed - minAvgWindSpeed) * scaleFactor + yOffset;
                        const z = (point.highWindDays15 - minHighWindDays15) * scaleFactor + zOffset;

                        const sphere = document.createElement('a-sphere');
                        sphere.setAttribute('position', `${x} ${y} ${z}`);
                        sphere.setAttribute('radius', '0.5');
                        sphere.setAttribute('color', getRegionalColor(point.prefecture));
                        sphere.setAttribute('class', 'clickable');
                        
                        // showInfo関数を修正
                        const showInfo = (p) => {
                            infoBox.style.display = 'block';
                            infoBox.innerHTML = `
                                <strong>都道府県:</strong> ${p.prefecture}<br>
                                <strong>年月:</strong> ${p.month}<br>
                                <strong>平均風速:</strong> ${p.avgWindSpeed} ${axisUnits.avgWindSpeed}<br>
                                <strong>日最大風速10m/s以上:</strong> ${p.highWindDays10} ${axisUnits.highWindDays10}<br>
                                <strong>日最大風速15m/s以上:</strong> ${p.highWindDays15} ${axisUnits.highWindDays15}
                            `;
                        };

                        sphere.addEventListener('mouseenter', () => {
                            if (!permanentInfo) {
                                showInfo(point);
                            }
                        });
                        sphere.addEventListener('mouseleave', () => {
                            if (!permanentInfo) {
                                infoBox.style.display = 'none';
                            }
                        });
                        
                        sphere.addEventListener('click', (e) => {
                            e.stopPropagation();
                            permanentInfo = point;
                            showInfo(point);
                        });
                        
                        el.appendChild(sphere);
                    });
                    
                    if (permanentInfo) {
                        infoBox.style.display = 'block';
                        infoBox.innerHTML = `
                            <strong>都道府県:</strong> ${permanentInfo.prefecture}<br>
                            <strong>年月:</strong> ${permanentInfo.month}<br>
                            <strong>平均風速:</strong> ${permanentInfo.avgWindSpeed} ${axisUnits.avgWindSpeed}<br>
                            <strong>日最大風速10m/s以上:</strong> ${permanentInfo.highWindDays10} ${axisUnits.highWindDays10}<br>
                            <strong>日最大風速15m/s以上:</strong> ${permanentInfo.highWindDays15} ${axisUnits.highWindDays15}
                        `;
                    }
                };
                
                const updateAxisLabels = (monthIndex) => {
                    document.querySelectorAll('.graph-label').forEach(el => el.remove());
                    const month = monthLabels[monthIndex];
                    
                    const monthLabel = document.createElement('a-text');
                    monthLabel.setAttribute('value', `month: ${month}\n\nstart&stop : Sspace key\nClear Display : Shift key`);
                    monthLabel.setAttribute('position', '50 20 -50');
                    monthLabel.setAttribute('color', 'black');
                    monthLabel.setAttribute('align', 'center');
                    monthLabel.setAttribute('width', '50');
                    monthLabel.classList.add('graph-label');
                    scene.appendChild(monthLabel);
                };

                const stopAnimation = () => {
                    if (animationInterval) {
                        clearInterval(animationInterval);
                        animationInterval = null;
                        animationMode = false;
                    }
                };
                
                document.addEventListener('keyup', (e) => {
                    if (e.key === ' ') {
                        animationMode = !animationMode;
                        if (animationMode) {
                            if (animationInterval) {
                                clearInterval(animationInterval);
                            }
                            currentMonthIndex = 0;
                            permanentInfo = null; // アニメーション開始で情報ボックスをリセット
                            drawGraph();
                            updateAxisLabels(currentMonthIndex);
                            animationInterval = setInterval(() => {
                                currentMonthIndex = (currentMonthIndex + 1) % monthLabels.length;
                                drawGraph();
                                updateAxisLabels(currentMonthIndex);
                            }, 1000);
                        } else {
                            stopAnimation();
                            drawGraph();
                            updateAxisLabels(currentMonthIndex);
                        }
                    } else if (e.key === 'Shift') {
                        permanentInfo = null;
                        infoBox.style.display = 'none';
                    }
                });
                
                fetch('MD2last.csv')
                    .then(response => response.text())
                    .then(processData)
                    .catch(error => {
                        console.error('Error fetching or parsing the CSV file:', error);
                    });
            }
        });
    </script>
</head>
<body>
    <a-scene cursor="rayOrigin: mouse" raycaster="objects: .clickable">
        <a-entity csv-graph="filterEnabled: true; showTrail: true"></a-entity>

        <a-entity line="start: 0 0 0; end: 100 0 0; color: #ff0000; opacity: 1"></a-entity>
        <a-entity line="start: 0 0 0; end: 0 100 0; color: #00ff00; opacity: 1"></a-entity>
        <a-entity line="start: 0 0 0; end: 0 0 100; color: #0000ff; opacity: 1"></a-entity>
        <a-grid position="0 0 0" material="color: #ccc; opacity: 0.5"></a-grid>
        <a-grid position="0 0 0" rotation="90 0 0" material="color: #ccc; opacity: 0.5"></a-grid>
        <a-grid position="0 0 0" rotation="0 0 90" material="color: #ccc; opacity: 0.5"></a-grid>

        <a-text value="X軸: Days above 10 m/s (日)" position="10 -10 -5" color="#ff0000" width="30" align="center"></a-text>
        <a-text value="Y軸: Average wind speed (m/s)" position="-10 10 -5" color="#00ff00" width="30" align="center"></a-text>
        <a-text value="Z軸: Days above 15 m/s (日)" position="-5 -10 10" color="#0000ff" width="30" align="center"></a-text>
        
        <a-entity id="cameraRig" position="0 5 20" rotation="0 0 0">
            <a-entity id="camera" camera look-controls wasd-controls></a-entity>
        </a-entity>
        <a-light type="ambient" color="#fff"></a-light>
        <a-light type="point" intensity="0.5" position="10 20 10"></a-light>

        <div class="info-box"></div>
        <div id="filter-ui">
            <label for="regional-filter">地域別フィルター:</label>
            <select id="regional-filter">
                <option value="">すべて</option>
            </select>
        </div>

        <div id="p-value-box">
            <p><b>p-value:</b> <span id="p-value-value"></span></p>
        </div>

    </a-scene>

     <script>
        const pValue = 0.0000;
        const rValue = 0.9010;
        const statisticalSignificance = 'p値は0.05より小さいため、この相関は統計的に有意です。';
        const analysisDescription = '「日最大風速10m/s以上の日数」と「日最大風速15m/s以上の日数」の相関';

        document.addEventListener('DOMContentLoaded', () => {
            const pValueBox = document.getElementById('p-value-box');
            if (pValueBox) {
                pValueBox.innerHTML = `
                    <p><b>分析:</b> ${analysisDescription}</p>
                    <p><b>相関係数 (r):</b> ${rValue.toFixed(4)}</p>
                    <p><b>p値:</b> ${pValue.toFixed(4)}</p>
                    <p>${statisticalSignificance}</p>
                `;
            }
        });
    </script>
</body>
</html>